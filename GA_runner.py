#############################################################################################
### Methods to build, run, and generate children and parents for a Genetic Algorithm (GA) ###
###                                                                                       ###
### Author:         Craig Waitt                                                           ###
### Date Created:   03/04/20                                                              ###
### Date Modified:  03/05/20                                                              ###
#############################################################################################

# General ASE and Python Modules Modules
import numpy as np
from ase.io import read, write
from ase.visualize import view
from ase import Atoms
from ase.build import molecule
from vasp import Vasp    # John Kitchins Vasp (will change from this when SGE and ASE are integratted)
import os
import glob
import matplotlib.pyplot as plt

# Import Modules for Genetic Algorithm (GA)
from ase.ga.data import PrepareDB
from ase.ga.bulk_startgenerator import StartGenerator
from ase.ga.utilities import closest_distances_generator, get_all_atom_types
from ase.neighborlist import NeighborList, natural_cutoffs
from ase.db.core import Database, connect
from ase.db import connect
from ase.ga.data import DataConnection
from ase.ga.population import Population
from ase.ga.standard_comparators import *
from ase.ga.bulk_crossovers import CutAndSplicePairing
from ase.ga.utilities import closest_distances_generator
from ase.ga.utilities import get_all_atom_types
from ase.ga.offspring_creator import OperationSelector

class GenerateZeoliteConfig(object):

    """ Class used to generate the initial configuration of starting candidates.
        The candidates are generated by placing the adsorbate into a unit cell
        whose size is predetermined based on the problem. The random configurations
        are then placed within a zeolite framework. Systems with overlapping atoms 
        removed and stored in a database for processing later.
        These classes are used in conjuction with predefined as GA modules

    """

    def __init__(self,FW,Ads,pop_size,n_ads,Start_Set=[],Parent_Set=[]):
        """ initialize class object """
        self.FW = FW
        self.Ads = Ads
        self.pop_size = pop_size
        self.n_ads = n_ads
        self.Start_Set = Start_Set
        self.Parent_Set = Parent_Set
        
    def set_ads_cell(self,ads_cell):
        """ place the adsorbate into a predifined unit cell for sampling """
        self.ads_cell = ads_cell
        ads_cell = self.ads_cell
        Ads_cell = [[ads_cell[0],0,0],[0,ads_cell[1],0],[0,0,ads_cell[2]]]
        self.Ads.set_cell(Ads_cell)
        self.Ads.center()

    def construct_init_parent(self,ads_cell,ads_pos):
        """ construct the initial set of parents """
        self.ads_cell = ads_cell
        self.ads_pos = ads_pos
        Ads_vol = ads_cell[0] * ads_cell[1] * ads_cell[2]
        Ads_cell = [[ads_cell[0],0,0],[0,ads_cell[1],0],[0,0,ads_cell[2]]]

        Atom_Num = self.Ads.get_atomic_numbers()                                # get atomic numbers of your adsorbate
        unique_atom_types = get_all_atom_types(self.FW, Atom_Num)               # get atomic numbers of your system
        cd = closest_distances_generator(atom_numbers=unique_atom_types,
                                        ratio_of_covalent_radii=0.7)            # Generate a dictionary of closest distances

        pop=self.pop_size

        sg = StartGenerator([(self.Ads,self.n_ads)],                            # Generator Parameters
                            cd,
                            Ads_vol,
                            cell = Ads_cell)

        starting_population = [sg.get_new_candidate() for i in range(pop)]
                            
        for i in range(pop):
            TEMPMOL = self.FW +  starting_population[i]                        # Add the adsorbates to the frame work
            self.Start_Set.append(TEMPMOL)
            
            
        Cent_Pos = self.ads_pos
        num = len(self.Ads)*self.n_ads
        Fin_atoms = np.linspace(0,num-1,num)

        for i in range(pop):
            for j in Fin_atoms:
                Coord = self.Start_Set[i].get_positions()[-(int(j)+1)] + Cent_Pos  # Move the corner of the adsorbate cell to p.o.i.
                self.Start_Set[i][-(int(j)+1)].x = Coord[0] - Ads_cell[0][0]/2                       # Then you have to fudge the box so its centered
                self.Start_Set[i][-(int(j)+1)].y = Coord[1] - Ads_cell[1][1]/2                      #      around the p.o.i.
                self.Start_Set[i][-(int(j)+1)].z = Coord[2] - Ads_cell[2][2]/2
                
            self.Start_Set[i].wrap()
        
    def remove_overlap(self,mul):
        """ remove parents with overlapping atoms """
        self.mul = mul

        Tot_Atoms = len(self.Start_Set[0])                                           # Get the total number of atoms
        Num_Ads = Tot_Atoms - len(self.Ads)*self.n_ads                          # Get the index of the first adsorbate atom
        ADS_ind = list(range(Num_Ads,Tot_Atoms))                                # Get indicies of each adsorbate

        Nat_Cut = natural_cutoffs(self.Start_Set[0])                            # Cutoff radii to get neighbors
        Candidate_Error = []                                                    # Storage for candidate overlaps
        for i in range(self.pop_size):
            Neigh = NeighborList(Nat_Cut,bothways=True)
            Neigh.update(self.Start_Set[i])                                     # Generate Neighbor list
    
            for a in ADS_ind:
                indices,offsets = Neigh.get_neighbors(a)                        # Get Indicies of neighbors of adsorbate atom a  
                indices = indices[:-1]                                          # remove adsorbate a from list leaving behind neighbors
                indices = indices[1:]                                          
                Distances = self.Start_Set[i].get_distances(a,indices)               # Get the distances of atom a and its neighbors

                Atom_Nat_Cut = []
                for m in indices:
                    Mol_Syms = self.Start_Set[i].get_chemical_symbols()              # Get the natural cutoff for each neighbor
                    Atom_Sym = Mol_Syms[m]
                    tmp_Atom = Atoms(Atom_Sym,positions=[(0,0,0)])
                    Atom_Nat_Cut.append(natural_cutoffs(tmp_Atom,mult=self.mul))
                    Atom_Nat_list = []
                    for l in Atom_Nat_Cut:
                        Atom_Nat_list += l
                
                Atom_Distance = Distances - Atom_Nat_list                       # Compute the overlap
        
                for num in Atom_Distance:                                       # Get Candidates with an overlap
                    if num <= 0:
                        Candidate_Error.append(i)
                        break
                    else:
                        continue

        Candidate_Error = np.unique(Candidate_Error)

        print('Out of {0} Candidates, {1} overlaps have been possibly detected!!!!'.format(len(self.Start_Set),len(Candidate_Error)))
        print(' ')
        print('{0} parent candidates will be used in the GA'.format(len(self.Start_Set)-len(Candidate_Error)))

        # Creat the Final parent set to put into a DB
        for i in range(0,len(self.Start_Set)):
            if i in Candidate_Error:
                continue
            self.Parent_Set.append(self.Start_Set[i])

        
class DB_Prep(object):

    """ Updates DB for GA """

    def __init__(self,db_name,directory,FW,Ads):
        self.db_name = db_name
        self.directory = directory
        self.FW = FW
        self.Ads = Ads

    def update_db(self):
        """ update the db with computed energies"""
    
        db = connect(self.db_name)
        rows = db.count()+1
        
        for i in range(2,rows):
            calc = Vasp(self.directory.format(int(i)))
            a = calc.get_atoms()
            a.set_tags(np.concatenate((np.zeros(len(self.FW)),np.ones(len(self.Ads)))))
            db.update(i,a,relaxed=False)

    def prep_db(self):
        """put scores on each parent"""
        
        db = connect(self.db_name)
        rows = db.count()-1
        
        da = DataConnection(self.db_name)    # The first row of the database contains the surface/framework w/out the adsorbate.
        struct = da.get_all_unrelaxed_candidates()
        for i in range(1,rows):    
            a = struct[i-1]
            da.c.update(a.info['confid'],atoms=None,            # update the DB with pertinent information
                        origin='StartingCandidateRelaxed',
                        raw_score= -a.get_potential_energy(),
                        relaxed=True)

class GenerateZeoliteGen1(object):
    
    def __init__(self,pop,n_to_test,db_name,Candidates=[]):
        self.pop = pop
        self.n_to_test = n_to_test
        self.db_name = db_name
        self.Candidates = Candidates
    
    def ga_init(self,ddiff,dmax,dE):
        self.ddiff = ddiff
        self.dmax = dmax
        self.dE = dE

        da = DataConnection(self.db_name)
        atom_numbers_to_optimize = da.get_atom_numbers_to_optimize()  # adsorbate atom numbers to optimize
        n_to_optimize = len(atom_numbers_to_optimize)                 # number of atoms to optimize
        slab = da.get_slab()
        all_atom_types = get_all_atom_types(slab, atom_numbers_to_optimize)
        blmin = closest_distances_generator(all_atom_types,
                                    ratio_of_covalent_radii=.7)   # closest distance atoms can be

        comp = InteratomicDistanceComparator(n_top=None,
                                             pair_cor_cum_diff=self.ddiff,
                                             pair_cor_max=dmax,
                                             dE=dE,
                                             mic=True)                   # comparator to determine if parents should make childer

        pairing = CutAndSplicePairing(blmin,None,use_tags=True,p1=.2)     # how children are generated (make sure your adsorbates are uniquely tagged)


        population = Population(data_connection=da,              
                        population_size=self.pop,
                        comparator=comp)

        
        
        for i in range(self.n_to_test):
            print('Now starting configuration number {0}'.format(i))
            a1, a2 = population.get_two_candidates()

            a3, desc = pairing.get_new_individual([a1, a2])
            #print(a3.info)
            #view(a3)
            if a3 is None:
                continue
            da.add_unrelaxed_candidate(a3, description=desc)

class GenerateZeoliteGen2(object):
    
    def __init__(self,pop,n_to_test,db_name,Candidates=[]):
        self.pop = pop
        self.n_to_test = n_to_test
        self.db_name = db_name
        self.Candidates = Candidates
    
    def ga_init(self,ddiff,dmax,dE):
        self.ddiff = ddiff
        self.dmax = dmax
        self.dE = dE

        da = DataConnection(self.db_name)
        atom_numbers_to_optimize = da.get_atom_numbers_to_optimize()  # adsorbate atom numbers to optimize
        n_to_optimize = len(atom_numbers_to_optimize)                 # number of atoms to optimize
        slab = da.get_slab()
        all_atom_types = get_all_atom_types(slab, atom_numbers_to_optimize)
        blmin = closest_distances_generator(all_atom_types,
                                    ratio_of_covalent_radii=.7)   # closest distance atoms can be

        comp = InteratomicDistanceComparator(n_top=None,
                                             pair_cor_cum_diff=self.ddiff,
                                             pair_cor_max=dmax,
                                             dE=dE,
                                             mic=True)                   # comparator to determine if parents should make childer

        pairing = CutAndSplicePairing(blmin,None,use_tags=True,p1=.2)     # how children are generated (make sure your adsorbates are uniquely tagged)


        population = Population(data_connection=da,              
                        population_size=self.pop,
                        comparator=comp)

        
        
        for i in range(self.n_to_test):
            print('Now starting configuration number {0}'.format(i))
            a1, a2 = population.get_two_candidates()

            a3, desc = pairing.get_new_individual([a1, a2])
            #print(a3.info)
            #view(a3)
            if a3 is None:
                continue
            da.add_unrelaxed_candidate(a3, description=desc)            

class DB_viewer(object):
    """ This class allows for post processing and analysis of the DB without updating it with new children"""

    def __init__(self,db_name):
        self.db_name = db_name
        #db = connect(self.db_name)
        
    def db_get_energies(self,gen0,gen1,gen2,zoom = False,interest=10):
        self.gen0 = gen0
        self.gen1 = gen1
        self.gen2 = gen2
        self.zoom = zoom
        self.interest = interest

        db = connect(self.db_name)

        E0 = []
        E1 = []
        E2 = []
        
        for i in range(2,gen0+2):
            E0.append(db.get_atoms(i).get_potential_energy())
        for j in range(gen0+2,gen0+2+gen1):
            E1.append(db.get_atoms(j).get_potential_energy())
        for k in range(gen0+2+gen1,gen0+2+gen1+gen2):
            E2.append(db.get_atoms(k).get_potential_energy())

        Emin = np.min(np.concatenate((E0,E1,E2)))
            
        if E0 == []:
            pass
        else:
            plt.plot(range(2,gen0+2),E0-Emin,'b',label = 'Parents')
        if E1 == []:
            pass
        else:
            plt.plot(range(gen0+3,gen0+3+gen1),E1-Emin,'r',label = 'Gen1')
        if E2 == []:
            pass
        else:
            plt.plot(range(gen0+3+gen1,gen0+3+gen1+gen2),E2-Emin,'g', label = 'Gen2')

        plt.ylabel('Relative Energy (eV)')
        plt.xlabel('Candidate')
        plt.legend()

        if zoom == True:
            plt.ylim([-0.01,1])
        plt.show()


